---
title: 'A crash course in just-in-time (JIT) compilers'
date: 2019-2-6 16:21:13
category: 'development'
thumbnail: './images/hello.png'
draft: false
author: 'test'
github: 'https://google.com'
profileImage: 'https://google.com'
introduction: 'hello world'
---

[A crash course in just-in-time (JIT) compilers - Mozilla Hacks - the Web developer blog](https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/)

이 글은 [웹어셈블리](https://gitlab.rsupport.com/webdev2/articles/blob/master/content/A_cartoon_intro_to_WebAssembly.md) 시리즈의 두 번째 부분으로 빠르게 진행됩니다. 만약 아직 다른 파트를 읽지 않았다면, 처음부터 시작하는 것을 추천합니다.

자바스크립트가 처음 나왔을 때는 느렸지만, JIT라는 것 때문에 빨라졌습니다. JIT는 어떻게 동작할까요?

## How JavaScript is run in the browser
개발자가 페이지에 자바스크립트를 추가하면 다음의 목표와 문제가 발생합니다.

목표 : 컴퓨터에게 무엇을 해야 하는지 알려주고 싶습니다.  
문제 : 당신과 컴퓨터가 이해하는 언어가 서로 다릅니다.

여러분은 인간의 언어로 말하고 컴퓨터는 기계어를 사용합니다. 여러분이 비록 자바스크립트나 다른 고급 프로그래밍 언어들을 인간의 언어로 생각하지 않는다 하여도 실제로 (프로그래밍 언어)는 기계 인식을 위한 것이 아니라 인간 인식을 위해 설계되었습니다.

그래서 자바스크립트 엔진의 역할은 인간의 언어를 기계가 이해하는 것으로 바꾸는 것입니다.

저는 이것을 인간과 외계인이 서로 대화하려는 스토리의 영화 “[컨택트(Arrival)](https://en.wikipedia.org/wiki/Arrival_(film))” 에서와 같이 생각하려고 합니다.

![](https://hacks.mozilla.org/files/2017/02/02-01-alien03-768x440.png)

이 영화에서는 인간과 외계인 사이에 서로의 언어 간(단어-와-단어) 번역을 사용하지 않습니다. 두 집단은 세상에 대해 서로 다른 사고방식을 가지고 있고, 이는 인간과 기계에 대해서도 마찬가지입니다. 

그렇다면 번역은 어떻게 이루어질까요?

프로그래밍에서는 일반적으로 인터프리터나 컴파일러를 사용하는 두 가지 방법으로 기계어로 번역할 수 있습니다. 

인터프리터를 이용하는, 번역의 경우에는 대게 line-by-line으로 진행이 됩니다. 

![](https://hacks.mozilla.org/files/2017/02/02-02-interp02-768x447.png)

반면에 컴파일러는 실행하는 시간보다 앞선 시간에 미리 번역을 작성합니다. 

![](https://hacks.mozilla.org/files/2017/02/02-03-compile02-768x456.png)

번역을 처리하는 이러한 각 방법에는 장 단점이 있습니다.

## Interpreter pros and cons

인터프리터는 재빠르게 시작하며 동작합니다. 코드를 실행하기 전에 전체 소스를 컴파일 할 필요가 없습니다. 단지 첫 번째 줄을 읽고 번역하고 실행하기 시작합니다.

웹 개발자가 작성한 코드를 빨리 실행해야 하는 것은 중요하며, 바로 이점 때문에 인터프리터는 자바스크립트 같은 언어와 잘 맞는 것 같습니다.

하지만 인터프리터 사용의 단점은 동일한 코드를 두 번 이상 실행할 때 발생합니다. 예를 들어, 루프 안에서의 (중복) 코드를 또 읽고 번역하고 계속 반복해야 합니다.

## Compiler pros and cons

컴파일러는 인터프리터와는 반대편의 절충점을 가지고 있습니다.

실행 전에 컴파일 단계를 거쳐야 하기 때문에 시작하는 데 조금 더 시간이 걸리지만, 루프를 통과할 때마다 변환을 반복할 필요가 없기 때문에 코드가 더 빨리 실행됩니다.

또 다른 차이점은 컴파일러가 인터프리터 보다 코드를 편집할 시간이 좀 더 많기 때문에 코드를 더 빨리 실행하는데 유리합니다. 이 편집 과정을 최적화라고 부릅니다. 

인터프리터는 런타임에 변환 작업을 해야 하기 때문에 이러한 최적화 방법을 알아내는 데 많은 시간을 할애하기 어렵습니다.

## Just-in-time compilers: the best of both worlds
인터프리터에서 루프를 통과할 때마다 코드를 계속해서 다시 번역해야 하는 비 효율성을 제거하기 위한 방법으로 컴파일러를 혼합하기 시작했습니다.

브라우저마다 약간 다른 방식으로 동작하지만, 기본적인 아이디어는 같습니다. 그들은 모니터(프로파일러라고 불리는)를 엔진의 새로운 부품으로 추가했습니다. 이 모니터는 실행되는 코드를 감시하고 실행 횟수 및 사용된 타입(유형)을 기록합니다.

처음 실행될 때에는 모든 코드가 인터프리터를 이용하여 실행됩니다.

![](https://hacks.mozilla.org/files/2017/02/02-04-jit02-768x561.png)

동일한 코드 라인이 몇 번 반복 실행되면 해당 코드 세그먼트를 warm이라고 부릅니다. 그리고 더 많이 실행되면, 그것을  hot이라고 부릅니다.

## Baseline compiler
함수가 따뜻해지기 시작하면 JIT가  컴파일을 시작합니다. 그런 다음 해당 컴파일을 저장합니다.

![](https://hacks.mozilla.org/files/2017/02/02-05-jit06-768x565.png)

함수의 각 행은 "스텁"으로 컴파일됩니다. 스텁은 행 번호와 변수 유형으로 색인화됩니다 (이점이 중요한 이유에 대해서는 나중에 설명하겠습니다). 모니터가 코드의 실행을 주시하다가  동일한 변수 타입을 사용하는 동일한 코드가 반복 실행하는 것으로 확인되면 컴파일 된 버전에서 꺼냅니다.

그것은 속도를 향상시키는데 도움을 주긴 하지만 제가 말했듯이, 컴파일러가 할 수 있는 것이 더 있습니다. 시간이 좀 더 걸릴 수는 있겠지만 가장 효율적인 방법을 찾는 것... 바로 최적화를 수행하는 일입니다. 

Baseline 컴파일러는 이러한 최적화 중 일부만을 수행합니다 (아래 예제를 예로 들겠습니다). 코드의 실행 시간이 너무 길어지는 것을 원치 않기 때문에 최적화 작업에 많은 시간을 들일 필요가 없습니다.

그러나 코드가 정말 뜨겁다면 (동일 코드가 빈번하게 실행되고 있다면) 더 많은 최적화 작업을 수행하는 것이 좋습니다.

## Optimizing compiler
코드의 일부가 매우 뜨거워지면 모니터가 이를 최적화 컴파일러에 보냅니다. 이렇게 하면  함수의 또 다른, 더 빠른 버전이 생성되고 저장됩니다.

![](https://hacks.mozilla.org/files/2017/02/02-06-jit09-768x560.png)

코드의 더 빠른 버전을 만들기 위해, 최적화 컴파일러는 몇 가지 추측을 해야 합니다.

예를 들어, 특정 생성자가 만든 모든 객체가 동일한 모양을 갖고 있다고 가정할 수 있는 경우(즉, 항상 동일한 속성명을 가지고 있는 경우), 해당 속성이 동일한 순서로 추가된 경우에는 이를 근거로 모서리를 좀 더 깎아낼 수 있습니다. (성능 향상을 이끌어 낸다고 이해함)

최적화 컴파일러는 모니터가 수집 한 정보를 사용하여 코드 실행을 관찰하고 판단을 합니다. 어떤 코드가 루프에서 직전의 모든 결과가 true였다면(일관된 코드라면), 계속해서 true 일 것이라고 가정합니다.

물론 자바스크립트는 절대 보장이 없습니다. 99개의 객체가 모두 같은 모양을 가지고 있다가도 100번째 객체에서 그 속성을 잃어 버릴 수 있습니다.

따라서 컴파일된 코드는 실행하기 전에 그 가정이 유효한지 확인해야 합니다. 만약 유효하지 않다면, JIT는 추측이 틀렸다고 가정하고 최적화된 코드를 버립니다.

![](https://hacks.mozilla.org/files/2017/02/02-07-jit11-768x555.png)

그런 다음 인터프리터(코드를 최초에 실행할 때처럼) 또는 baseline 컴파일 된 버전으로 돌아가서 실행됩니다. 이 과정을 deoptimization (또는 bailing out) 이라고 부릅니다..

일반적으로 최적화 컴파일러가 만들어낸 코드는 빠르게 실행되지만 때로는 예상치 못한 성능 문제를 일으킬 수 있습니다. 최적화되었다가 deoptimized된 코드가 있다면 baseline 컴파일 된 버전을 실행하는 것보다 느리게 실행될 수 있습니다.

대부분의 브라우저에는 이러한 최적화 / 최적화 해제 사이클이 발생할 때 벗어 날 수있는 허용 한도가 추가되었습니다. 만약 JIT가 최적화 시도를 10회 이상 시도(하였고 keeps having to throw it out - 원문) 했다면 최적화 시도를 멈추게 됩니다. 

## An example optimization: Type specialization
많은 종류의 최적화 방법이 있지만 그 중 한가지 유형을 살펴보면 최적화가 발생하는 방식에 대한 느낌을 얻을 수 있습니다. 컴파일러를 최적화하는 방법 중 가장 많이 알려진 방식은 유형 특수화(type specialization)에서 유래된 방식입니다.

자바스크립트처럼 동적 타입 시스템의 런타임은 약간의 추가 작업을 필요로 합니다.
예를 들어, 다음의 코드를 살펴보세요.

```js
function arraySum(arr) {
  var sum = 0;
  for (var i = 0; i < arr.length; i++) {
    sum += arr[i];
  }
}
```

루프 안에서 += 스텝은 하나의 연산만 수행하는 것 처럼 단순해 보이지만 동적 타이핑 때문에 예상보다 많은 단계가 필요 합니다.

arr 변수가 100 개의 정수로 이루어진 배열이라고 가정합시다. 일단 코드가 워밍업 되면(반복 실행되면) baseline 컴파일러는 함수의 각 operation에 ​​대한 스텁을 생성합니다. 따라서 정수의 가산 연산(+=)을 처리하는 sum += arr [i]에 대한 스텁이 만들어집니다.

그러나 sum과 arr [i]를 정수라고 보장하기 어렵습니다. 자바스크립트의 타입은 동적이기 때문에 이후의 루프에서 arr [i] 값이 문자열이 될 가능성이 있습니다. 정수의 더하기 연산과 문자열 연결(concatenation)은 다른 operation이기 때문에 마찬가지로 다른 머신 코드로 컴파일 됩니다. 

JIT가 이것을 처리하는 방법은 여러 개의 baseline 스텁을 컴파일하는 것입니다. 코드 조각이 monomorphic 인 경우 (즉, 항상 같은 타입으로 호출되는 경우) 하나의 스텁이 만들어집니다. 만약 다형성(하나의 경로에서 또 다른 코드를 다양한 타입으로  호출하는) 경우, 해당 연산을 통해 나온 각각의 타입 조합들의 스텁이 만들어집니다.

이는 JIT가 스텁을 선택하기 전에 많은 질문을 해야 한다는 것을 의미합니다.

![](https://hacks.mozilla.org/files/2017/02/02-08-decision_tree01-768x394.png)

각 코드 라인은 baseline 컴파일러에 고유한 스텁 세트를 가지고 있기 때문에 JIT는 코드 라인이 실행될 때마다 타입을 계속 확인해야 합니다. 그래서 루프를 통해 반복될 때마다, 동일한 질문을 해야 합니다. 

![](https://hacks.mozilla.org/files/2017/02/02-09-jit_loop02-768x496.png)

만약 JIT가 그러한 점검을 반복할 필요가 없다면 그 코드는 훨씬 더 빨리 실행될 수 있습니다. 이것이 최적화 컴파일러가 하는 일 중 하나입니다.

최적화 컴파일러에서는 전체 함수가 함께 컴파일 됩니다. 타입 검사는 루프 전에 수행됩니다. 

![](https://hacks.mozilla.org/files/2017/02/02-10-jit_loop02-768x488.png)

일부 JIT는 이를 좀 더  최적화합니다. 예를 들어, Firefox에는 정수 만 포함하는 배열에 대한 특별한 명세가 있습니다. arr 변수가 이러한 배열 중 하나인 경우 JIT는 arr [i]가 정수인지 확인하지 않아도 됩니다. 즉, JIT가 루프에 들어가기 전에 전체 타입 검사를 수행할 수 있다는 의미입니다.

## Conclusion
그것이 바로 JIT입니다. 코드가 실행되는 것을 모니터링하고 최적화할 핫 코드의 경로를 전송하여 자바스크립트를 보다 빠르게 실행할 수 있습니다. 이런 결과로 대부분의 자바스크립트 어플리케이션에서 성능이 여러 배 향상되었습니다. 

이러한 개선에도 불구하고 자바스크립트의 성능은 여전히 예측할 수 없습니다.  그래서 JIT는 보다 빠른 성능을 위해 런타임에 약간의 오버헤드를 추가하였습니다. 

* 최적화(optimization) 최적화 해제(deoptimization)
* bailouts 발생 시 모니터의 bookkeeping 과 복구 정보에 이용되는 메모리
* baseline 컴파일러와 최적화 컴파일러에 저장된 버전을 사용하는데 쓰이는 메모리

아직 개선할 여지가 남아 있습니다. 오버헤드를 제거하여 성능을 예측 가능 하도록 만들 수 있습니다. 이것이 웹어셈블리가 하는 것 중 하나입니다.

[다음 기사](https://hacks.mozilla.org/2017/02/a-crash-course-in-assembly/) 에서는 어셈블리와 컴파일러가 어떻게 작동하는지에 대해 자세히 설명 할 것입니다.



